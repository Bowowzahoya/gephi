# -*- coding: utf-8 -*-
"""
Functions for dealing with Lens patent data
all on the basis of filename

- get_node()
- get_edge()
- get_int_sim(): internal cosine similarity
"""

import pandas as pd

from ..mixin_tools import cossim
from ..constants import LENS_ID_COL, TITLE_COL

class NodeGetter():
    MAX_EXPORT_LENGTH = 50_000
    MARGIN = 10
    def __init__(self, known_node_sizes=pd.Series()):
        self.known_node_sizes = known_node_sizes
        
    def get_node_size(filename):
        if filename in self.known_node_sizes.index:
            return known_node_sizes[filename]
        # else
        lens_export = _read(filename)
        if len(lens_export) >= MAX_EXPORT_LENGTH-MARGIN:
            print(f"WARNING: export '{filename}' at max length"+\
                  f" of {MAX_EXPORT_LENGTH}, but no node size provided.")
        return len(lens_export)
    
    def get_node_internal_similarity(self, filename, 
                                     max_length_to_calc=20_000):
        lens_export = _read(filename)
        lens_export = lens_export.iloc[:max_length_to_calc]
        
        titles = lens_export[TITLE_COL].copy()
        titles = titles.dropna()
        internal_cosine_similarity = get_internal_cosine_similarity(titles)
        return ics
    
class EdgeGetter():
        
    
def _read(filename):
    return pd.read_csv(fname, 
                       error_bad_lines=False, 
                       warn_bad_lines=False)



def get_edge(fname1, fname2, known_ams=pd.Series(), fold=""):
    """
    Returns edge strength between two nodes
    
    Takes care of fact that might be only partly downloaded
    by using known_ams

    Parameters
    ----------
    fname1 : str
        Content filename for node 1
    fname2 : str
        Content filename for node 2
    known_ams : Series
        Dictionary of known amounts per filename

    Returns
    -------
    strgth : Series
        edges of node, with index node pair, value strength
    """
    df1 = read(fold+fname1)
    df2 = read(fold+fname2)
    
    am1 = known_ams.get(fname1, len(df1))
    am2 = known_ams.get(fname2, len(df2))

    min_cov = min(len(df1)/am1, len(df2)/am2)
    
    overlap = df1[df1[LID_COL].isin(df2[LID_COL])]
    return (len(overlap)/am1)/min_cov

def get_int_sim(fname, fold="", max_=20000):
    """
    Returns internal similarity of a node
    
    will calculate based on cosine similarity of titles

    Parameters
    ----------
    fname : str
        Content filename for node


    Returns
    -------
    int_sim : float
        internal similarity

    """
    
    

